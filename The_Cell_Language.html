<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>1&nbsp;The Cell Language</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="racket.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9660;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">Nocell Documentation</a></td></tr></table></div><div class="tocviewsublisttop" style="display: block;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="The_Cell_Language.html" class="tocviewselflink" data-pltdoc="x">The Cell Language</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="The_Grid_Language.html" class="tocviewlink" data-pltdoc="x">The Grid Language</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="ods.html" class="tocviewlink" data-pltdoc="x">Grid-<wbr></wbr>to-<wbr></wbr>Ods Backend</a></td></tr><tr><td align="right"></td><td><a href="doc-index.html" class="tocviewlink" data-pltdoc="x">Index</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9658;</a></td><td>1&nbsp;</td><td><a href="The_Cell_Language.html" class="tocviewselflink" data-pltdoc="x">The Cell Language</a></td></tr></table><div class="tocviewsublistbottom" style="display: none;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right">1.1&nbsp;</td><td><a href="The_Cell_Language.html#%28part._.Motivation%29" class="tocviewlink" data-pltdoc="x">Motivation</a></td></tr><tr><td align="right">1.2&nbsp;</td><td><a href="The_Cell_Language.html#%28part._.Array-based_.Programming%29" class="tocviewlink" data-pltdoc="x">Array-<wbr></wbr>based Programming</a></td></tr><tr><td align="right"></td><td><a href="The_Cell_Language.html#%28part._doc-bibliography%29" class="tocviewlink" data-pltdoc="x">Bibliography</a></td></tr></table></div></div></div><div class="tocsub"><div class="tocsubtitle">On this page:</div><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber">1.1<tt>&nbsp;</tt></span><a href="#%28part._.Motivation%29" class="tocsubseclink" data-pltdoc="x">Motivation</a></td></tr><tr><td><span class="tocsublinknumber">1.2<tt>&nbsp;</tt></span><a href="#%28part._.Array-based_.Programming%29" class="tocsubseclink" data-pltdoc="x">Array-<wbr></wbr>based Programming</a></td></tr><tr><td><span class="tocsublinknumber">1.2.1<tt>&nbsp;</tt></span><a href="#%28part._.Arrays__rank__and_shape%29" class="tocsubseclink" data-pltdoc="x">Arrays:<span class="mywbr"> &nbsp;</span> rank, and shape</a></td></tr><tr><td><span class="tocsublinknumber">1.2.2<tt>&nbsp;</tt></span><a href="#%28part._.Rank_polymorphism__frames_and_cells%29" class="tocsubseclink" data-pltdoc="x">Rank polymorphism:<span class="mywbr"> &nbsp;</span> frames and cells</a></td></tr><tr><td><span class="tocsublinknumber">1.2.3<tt>&nbsp;</tt></span><a href="#%28part._.Rank_polymorphism_in_function_position%29" class="tocsubseclink" data-pltdoc="x">Rank polymorphism in function position</a></td></tr><tr><td><span class="tocsublinknumber">1.2.4<tt>&nbsp;</tt></span><a href="#%28part._.Higher_order_functions%29" class="tocsubseclink" data-pltdoc="x">Higher order functions</a></td></tr><tr><td><span class="tocsublinknumber"></span><a href="#%28part._doc-bibliography%29" class="tocsubseclink" data-pltdoc="x">Bibliography</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="version">7.8</span></div><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="index.html" title="backward to &quot;Nocell Documentation&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;Nocell Documentation&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="The_Grid_Language.html" title="forward to &quot;2 The Grid Language&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div><h3>1<tt>&nbsp;</tt><a name="(part._.The_.Cell_.Language)"></a>The Cell Language</h3><h4>1.1<tt>&nbsp;</tt><a name="(part._.Motivation)"></a>Motivation</h4><p>Cell is intented to be a sort of &lsquo;intermediate&rsquo; or &lsquo;core&rsquo; language for abstract
spreadsheets. Real spreadsheets are two-dimensional arrangements of expressions;
where the expressions consist solely of constants and built-in, first-order
functions. The Grid language is simply a representation of these, suitable for
direct transformation into a specific spreadsheet program. As such, Grid is
intended to be a &lsquo;back-end,&rsquo; so that the programmer does not have to think about
the specific output format being targetted, but it is not a convenient language.</p><p>By contrast, Cell is intended to be a language for describing &lsquo;spreadsheets&rsquo; of
arbitrary dimension and having higher-order functions.</p><p>What would such a language be? The obvious place to look for inspiration is the
&lsquo;array languages,&rsquo; most notably APL, its successor J, and various ideas which
these inspired. An array language has arrays as its primitive datatype and this
seems to align well with the idea of a spreadsheet as being &lsquo;a rectangular
grid.&rsquo;</p><p>Furthermore, the higher-order functions in array languages are naturally those
which express &lsquo;structured recursion&rsquo; over arrays. For example <span class="stt">fold</span> (or
<span class="stt">reduce</span>) and <span class="stt">map</span> are natural ways of applying primitive functions to
arrays. These functions implement restricted forms of recursion which are
guaranteed to terminate.</p><p>Recent work that looks particularly relevant is that by Slepak <span style="font-style: italic">et al<span class="Sendabbrev">.</span></span>
on &lsquo;Remora&rsquo; [<a href="The_Cell_Language.html#%28cite._remora%29" data-pltdoc="x">remora</a>, <a href="The_Cell_Language.html#%28cite._remora2%29" data-pltdoc="x">remora2</a>, <a href="The_Cell_Language.html#%28cite._remora3%29" data-pltdoc="x">remora3</a>] which describes a slightly more
general version of an abstract array language, as well as follow-on work by
Gibbons [<a href="The_Cell_Language.html#%28cite._gibbons2017%29" data-pltdoc="x">gibbons2017</a>].</p><p>However, compared to these languages, we have an additional challenge, which is
that the &lsquo;values&rsquo; of Cell are not only arrays. Instead, the value of a Cell
program contains also first-order functions and general expressions consisting
of these. Cell is more like a language for writing &lsquo;programs&rsquo;&#8212;<wbr></wbr>specifically,
first-order, array-based programs. That means it needs to have values that can
represent expressions.</p><h4>1.2<tt>&nbsp;</tt><a name="(part._.Array-based_.Programming)"></a>Array-based Programming</h4><p>The following is a summary of the treatment of arrays in [<a href="The_Cell_Language.html#%28cite._remora%29" data-pltdoc="x">remora</a>].</p><h5>1.2.1<tt>&nbsp;</tt><a name="(part._.Arrays__rank__and_shape)"></a>Arrays: rank, and shape</h5><p>Arrays are &lsquo;rectangular arrangements of numbers&rsquo;. Put differently, arrays are
vectors of vectors (of vectors...). But not all vectors of vectors are arrays,
only ones which are &lsquo;rectangular,&rsquo; in the sense that the &lsquo;inner&rsquo; vectors all
have the same length. This idea is captured in the follow definitions.</p><p>A <a name="(tech._rank._0._array)"></a><span style="font-style: italic">rank-0 array</span> is an ordinary, scalar value, called an <a name="(tech._atom)"></a><span style="font-style: italic">atom</span>
in the language of array-based programming. For definiteness, suppose that our
only atoms are real numbers.</p><p>A <a name="(tech._rank._1._array)"></a><span style="font-style: italic">rank-1 array</span> (sometimes called a vector) is a finite, ordered
sequence of <a href="The_Cell_Language.html#%28tech._atom%29" class="techoutside" data-pltdoc="x"><span class="techinside">atoms</span></a>. We write a <a href="The_Cell_Language.html#%28tech._rank._1._array%29" class="techoutside" data-pltdoc="x"><span class="techinside">rank-1 array</span></a> in square brackets; for
example: <span style="font-style: italic"></span>[<span style="font-style: italic"></span>1<span style="font-style: italic"></span>0<span style="font-style: italic"> </span>2<span style="font-style: italic"></span>0<span style="font-style: italic"> </span>3<span style="font-style: italic"></span>0<span style="font-style: italic"></span>]<span style="font-style: italic"></span>.</p><p>A <a name="(tech._rank._2._array)"></a><span style="font-style: italic">rank-2 array</span> is a finite, ordered sequence of <a href="The_Cell_Language.html#%28tech._rank._1._array%29" class="techoutside" data-pltdoc="x"><span class="techinside">rank-1 arrays</span></a>,
all of which have the same length. For example, <span style="font-style: italic"></span>[<span style="font-style: italic"></span>[<span style="font-style: italic"></span>1<span style="font-style: italic"></span>0<span style="font-style: italic"> </span>2<span style="font-style: italic"></span>0<span style="font-style: italic"> </span>3<span style="font-style: italic"></span>0<span style="font-style: italic"></span>]<span style="font-style: italic"> </span>[<span style="font-style: italic"></span>1<span style="font-style: italic"></span>0<span style="font-style: italic"></span>0<span style="font-style: italic"> </span>2<span style="font-style: italic"></span>0<span style="font-style: italic"></span>0<span style="font-style: italic"></span><span style="font-style: italic">
</span><span style="font-style: italic"></span>3<span style="font-style: italic"></span>0<span style="font-style: italic"></span>0<span style="font-style: italic"></span>]<span style="font-style: italic"></span>]<span style="font-style: italic"></span> is a rank-2 array, whereas <span style="font-style: italic"></span>[<span style="font-style: italic"></span>[<span style="font-style: italic"></span>1<span style="font-style: italic"></span>0<span style="font-style: italic"> </span>2<span style="font-style: italic"></span>0<span style="font-style: italic"></span>]<span style="font-style: italic"> </span>[<span style="font-style: italic"></span>1<span style="font-style: italic"></span>0<span style="font-style: italic"></span>0<span style="font-style: italic"> </span>2<span style="font-style: italic"></span>0<span style="font-style: italic"></span>0<span style="font-style: italic"> </span>3<span style="font-style: italic"></span>0<span style="font-style: italic"></span>0<span style="font-style: italic"></span>]<span style="font-style: italic"></span>]<span style="font-style: italic"></span> is not an
array. The <a name="(tech._shape)"></a><span style="font-style: italic">shape</span> of a rank-2 array is a vector of length 2 whose
elements are the number of inner vectors and the length of an inner vector
(noting that all inner vectors have the same length). For example, the shape of
<span style="font-style: italic"></span>[<span style="font-style: italic"></span>[<span style="font-style: italic"></span>1<span style="font-style: italic"></span>0<span style="font-style: italic"> </span>2<span style="font-style: italic"></span>0<span style="font-style: italic"> </span>3<span style="font-style: italic"></span>0<span style="font-style: italic"></span>]<span style="font-style: italic"> </span>[<span style="font-style: italic"></span>1<span style="font-style: italic"></span>0<span style="font-style: italic"></span>0<span style="font-style: italic"> </span>2<span style="font-style: italic"></span>0<span style="font-style: italic"></span>0<span style="font-style: italic"> </span>3<span style="font-style: italic"></span>0<span style="font-style: italic"></span>0<span style="font-style: italic"></span>]<span style="font-style: italic"></span>]<span style="font-style: italic"></span> is <span style="font-style: italic"></span>[<span style="font-style: italic"></span>2<span style="font-style: italic"> </span>3<span style="font-style: italic"></span>]<span style="font-style: italic"></span>. (The shape of rank-1 array is
a vector of length 1 whose element is the length of the array.)</p><p>More generally a <a name="(tech._rank._n)"></a><span style="font-style: italic">rank-<span style="font-style: italic">n</span></span> array is a vector of rank-<span style="font-style: italic"></span>(<span style="font-style: italic">n-</span>1<span style="font-style: italic"></span>)<span style="font-style: italic"></span>
arrays all having the same shape. The shape of a rank-<span style="font-style: italic">n</span> array is the
vector consisting of the length of the array followed by the elements of the
shape of the sub-arrays. The <a name="(tech._rank)"></a><span style="font-style: italic">rank</span> of an array is the length of its
shape. For example, a rank-3 array with shape <span style="font-style: italic"></span>[<span style="font-style: italic"></span>5<span style="font-style: italic">, </span>2<span style="font-style: italic">, </span>3<span style="font-style: italic"></span>]<span style="font-style: italic"></span> is &lsquo;a vector of
length 5, whose elements are vectors of length 2 having elements that are
vectors of real of length 3.&rsquo;</p><h5>1.2.2<tt>&nbsp;</tt><a name="(part._.Rank_polymorphism__frames_and_cells)"></a>Rank polymorphism: frames and cells</h5><p>Suppose one has a function on atoms, <span style="font-style: italic">f</span> : &#8477; &#8594; &#8477;. There is a natural way to
&lsquo;lift&rsquo; this function to operate on rank-1 arrays (of any length): apply <span style="font-style: italic">f</span>
to each element of the array. The result is a rank-1 array. (This is the
higher-order function, <span class="RktSym">map</span>, of course.) Indeed, one can naturally map
<span style="font-style: italic">f</span> over an array of <span style="font-style: italic">any</span> rank (and any shape): apply <span style="font-style: italic">f</span> to
every atom, giving as a result an array of the same shape as the input.</p><p>The same trick applies to binary operators &#8477;&#215;&#8477; &#8594; &#8477;. Given two arrays of
identical shape, apply the operator, component-wise, to the individual atoms.</p><p>So there is a sort of built-in polymorphism to array-based programming. What if
we have a function which takes an <span style="font-style: italic">array</span> as an argument? For example,
consider the function which sums the elements of a vector, <span style="font-style: italic">sum</span> : {1} &#8594;
&#8477;. (The notation {1} means &lsquo;an array of rank 1.&rsquo; This is not the notation used
by Slepak <span style="font-style: italic">et al<span class="Sendabbrev">.</span></span>.) Suppose we apply <span style="font-style: italic">sum</span> to an array of rank 2?
What meaning could be ascribed to <span style="font-style: italic">sum A</span>, where <span style="font-style: italic">A</span> is the array [[1
2] [3 4]]?</p><p>It&rsquo;s reasonably intuitive that one should apply the <span style="font-style: italic">sum</span> to each element
of <span style="font-style: italic">A</span>; each element of <span style="font-style: italic">A</span> is a rank-1 array, so just the sort of
thing that <span style="font-style: italic">sum</span> wants to act on. The result is [3 7], a rank 1 array.</p><p>In order to capture this intution, Slepak <span style="font-style: italic">et al<span class="Sendabbrev">.</span></span> introduce a further
terminology. Suppose we have an array of shape <span style="font-style: italic"></span>[<span style="font-style: italic">s</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>1<span style="font-style: italic"></span></span><span style="font-style: italic"> s</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>2<span style="font-style: italic"></span></span><span style="font-style: italic"> s</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>3<span style="font-style: italic"></span></span><span style="font-style: italic"></span><span style="font-style: italic">
</span><span style="font-style: italic">... s</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic">n</span></span><span style="font-style: italic"></span>]<span style="font-style: italic"></span>. Consider a parition of the shape into two shapes: <span style="font-style: italic"></span>[<span style="font-style: italic">s</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>1<span style="font-style: italic"></span></span><span style="font-style: italic"></span><span style="font-style: italic">
</span><span style="font-style: italic">... s</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic">i</span></span><span style="font-style: italic"></span>]<span style="font-style: italic"></span> and <span style="font-style: italic"></span>[<span style="font-style: italic">s</span><span style="vertical-align: sub; font-size: 80%">i+1</span><span style="font-style: italic"> ... s</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic">n</span></span><span style="font-style: italic"></span>]<span style="font-style: italic"></span>. The first shape is called (by
Slepak <span style="font-style: italic">et al<span class="Sendabbrev">.</span></span>) a <a name="(tech._frame)"></a><span style="font-style: italic">frame</span> and the second shape is called a
<a name="(tech._cell)"></a><span style="font-style: italic">cell</span>. (Thus, for example, the sum of the ranks of the frame and of the
cell is the rank of the original array, and there are <span style="font-style: italic">n+</span>1<span style="font-style: italic"></span> ways to
decompose an array into frame and cell.)</p><p>To apply a function requiring an argument of a particular rank, we decompose its
actual argument so that the cell of the decomposition is of the required
rank. <span class="refelem"><span class="refcolumn"><span class="refcontent">TODO: Note that the decomposition is by rank, not by
shape. That is, functions that operate on rank-1 arrays must operate on rank-1
arrays of any length, and so on.</span></span></span> Then we map the function over the
<span style="font-style: italic">frame</span>, applying it to each individual cell. The result has a frame that
is the same as the original frame, and a cell whose shape is determined by the
result of the function. The same idea applies to functions of multiple
arguments, if the frames of the actual arguments are identical.</p><p>Remora&rsquo;s rank polymorphism on functions of more than one argument is actually
slightly more general than this.</p><p>First, each actual argument is decomposed as above into a frame and a cell,
according to the required shape of the formal argument. The frame with the
greatest rank is called the <span style="font-style: italic">principal frame</span>. It is required that the
shape of the frame of every argument be a prefix of the shape of the principle
frame.</p><p>Each shorter frame is now extended to the shape of the principle frame by
replicating its cell as necessary. Then the polymorphism proceeds as before.</p><h5>1.2.3<tt>&nbsp;</tt><a name="(part._.Rank_polymorphism_in_function_position)"></a>Rank polymorphism in function position</h5><p>In Remora, the function position of an application may also be an array (an
array of functions). The process of extending the rank applies to this position
as well. In particular, this appears to be what happens in the process of
&lsquo;automatic mapping&rsquo;. Thus, for example, in the expression <span class="RktPn">(</span><span class="RktSym">+</span><span class="stt"> </span><span class="RktPn">[</span><span class="RktVal">1</span><span class="stt"> </span><span class="RktVal">2</span><span class="RktPn">]</span><span class="stt"> </span><span class="RktPn">[</span><span class="RktVal">10</span><span class="stt"> </span><span class="RktVal">20</span><span class="RktPn">]</span><span class="RktPn">)</span> the function position has rank 0, so the expression becomes
<span class="RktPn">(</span><span class="RktPn">[</span><span class="RktSym">+</span><span class="stt"> </span><span class="RktSym">+</span><span class="RktPn">]</span><span class="stt"> </span><span class="RktPn">[</span><span class="RktVal">1</span><span class="stt"> </span><span class="RktVal">2</span><span class="RktPn">]</span><span class="stt"> </span><span class="RktPn">[</span><span class="RktVal">10</span><span class="stt"> </span><span class="RktVal">20</span><span class="RktPn">]</span><span class="RktPn">)</span> which reduces to <span class="RktPn">[</span><span class="RktVal">11</span><span class="stt"> </span><span class="RktVal">22</span><span class="RktPn">]</span>.</p><p>Note: I imagine that the rank of the function array is taken to be its entire
frame.</p><p>Note: I don&rsquo;t know what to call the rank of a function that &lsquo;takes an array of
at least rank 1 and maps another function across its immediate sub-arrays.&lsquo; It
seems here we are specifying the rank of the frames of its arguments.</p><h5>1.2.4<tt>&nbsp;</tt><a name="(part._.Higher_order_functions)"></a>Higher order functions</h5><p>Remora provides several versions of reduce, scan, fold, and trace.</p><p>Reduce is like fold, but restricted to associative functions. Scan is the
&lsquo;prefix partials&rsquo; version of reduce; and scan is the &lsquo;prefix partials&rsquo; version
of fold.</p><h4><a name="(part._doc-bibliography)"></a>Bibliography</h4><p><table cellspacing="0" cellpadding="0" class="RBibliography"><tr><td><a name="(cite._remora)"></a>[remora]</td><td><span class="hspace">&nbsp;</span></td><td><span class="bibentry">Justin Slepak, Olin Shivers, and
  Panagiotis Manolios, &ldquo;An Array-Oriented Language
  with Static Rank Polymorphism,&rdquo; in Programming Languages and Systems
  (pp. 27&ndash;46), 2014. <a href="http://www.ccs.neu.edu/home/pete/pub/esop14-full.pdf"><span class="stt">http://www.ccs.neu.edu/home/pete/pub/esop14-full.pdf</span></a></span></td></tr><tr><td><a name="(cite._remora2)"></a>[remora2]</td><td><span class="hspace">&nbsp;</span></td><td><span class="bibentry">Justin Slepak,
  Olin Shivers, and Panagiotis Manolios, &ldquo;Records with Rank Polymorphism,&rdquo; in ARRAY 2019, 2019. <a href="https://www.ccs.neu.edu/~jrslepak/array19.pdf"><span class="stt">https://www.ccs.neu.edu/~jrslepak/array19.pdf</span></a></span></td></tr><tr><td><a name="(cite._remora3)"></a>[remora3]</td><td><span class="hspace">&nbsp;</span></td><td><span class="bibentry">Olin Shivers, Justin Slepak, and Panagiotis Manolios, &ldquo;An Introduction to Rank-polymorphic Programming in Remora
  (Draft),&rdquo; arXiv:1912.13451v2 [cs.PL], 2020. <a href="https://arxiv.org/abs/1912.13451"><span class="stt">https://arxiv.org/abs/1912.13451</span></a></span></td></tr><tr><td><a name="(cite._gibbons2017)"></a>[gibbons2017]</td><td><span class="hspace">&nbsp;</span></td><td><span class="bibentry">Jeremy Gibbons, &ldquo;APLicative Programming with Naperian Functors,&rdquo; Hongseok Yang, editor, European Symposium on
  Programming. Vol. 10201 of LNCS. Pages 568&#8722;583., 2017. <a href="http://www.cs.ox.ac.uk/people/jeremy.gibbons/publications/aplicative.pdf"><span class="stt">http://www.cs.ox.ac.uk/people/jeremy.gibbons/publications/aplicative.pdf</span></a></span></td></tr></table></p><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="index.html" title="backward to &quot;Nocell Documentation&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;Nocell Documentation&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="The_Grid_Language.html" title="forward to &quot;2 The Grid Language&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>