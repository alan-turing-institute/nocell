#lang scribble/manual

@require[scribble/bnf]
@require[scribble/core
         scribble/decode]

@title{The Grid Language (work in progress)}
@author{James Geddes}

@centered{@bold{The following material is work in progress}}

Grid is a language for describing spreadsheets, although to call it a ``language''
is perhaps overblown. It is @emph{declarative}, in the sense that it merely
describes the structure and content of a spreadsheet. A grid program may be
straightforwardly converted into a specific spreadsheet application, such as the
Open Document Format for Office Applications (ODF).

We don't define an external form for a grid program. Instead, it exists as an
internal data structure (perhaps generated by a cell program). The following is
a semi-formal description.

@(define (term name)
   (make-element 'bold name))

@(define (BNF-struct name . fields)
   (make-element #f (append (list (make-element 'roman "("))
                            (list (apply BNF-seq
                                         (cons name
                                               (decode-content fields))))
                            (list (make-element 'roman ")")))))

@; --- pseq makes a parenthesised sequence. 
@(define (BNF-pseq . fields)
   (make-element #f (append (list (make-element 'roman "("))
                            (list (apply BNF-seq (decode-content fields)))
                            (list (make-element 'roman ")")))))

@BNF[(list @nonterm{grid-program}
           @BNF-seq[@nonterm{grid-meta}
                    @kleeneplus[@nonterm{sheet}]])
     (list @nonterm{sheet}
           @BNF-seq[@nonterm{sheet-meta}
                    @optional[@nonterm{row-styles}]
                    @optional[@nonterm{column-styles}]
                    @kleeneplus[@nonterm{row}]])
     (list @nonterm{row}
           @kleeneplus[@nonterm{cell}])
     (list @nonterm{cell}
           @BNF-seq[@nonterm{cell-content} @optional[@nonterm{cell-style}]])
     (list @nonterm{cell-content}
           @litchar{empty}
           @nonterm{expression})
     (list @nonterm{expression}
           @nonterm{value}
           @nonterm{application})
     (list @nonterm{value}
           @nonterm{atomic-value}
           @nonterm{array-value}
           @nonterm{reference})
     (list @nonterm{atomic-value} @BNF-alt[@nonterm{number}
                                           @nonterm{string}
                                           @nonterm{boolean}
                                           @nonterm{error}])
     (list @nonterm{application}
           @BNF-seq[@nonterm{built-in} @kleeneplus[@nonterm{expression}]])
     (list @nonterm{grid-meta}
           @BNF-etc)
     (list @nonterm{sheet-meta}
           @BNF-etc)
     (list @nonterm{row-styles}
           @BNF-etc)
     (list @nonterm{column-styles}
           @BNF-etc)
     (list @nonterm{cell-style}
           @BNF-etc)
     (list @nonterm{array-value}
           @BNF-etc)
     (list @nonterm{reference}
           @BNF-etc)
     (list @nonterm{error}  
           @BNF-etc)]

@section{Structure}

A `spreadsheet,' such as an Excel spreadsheet, is a list of worksheets, each of
which is a two-dimensional array of cells. In Grid, a worksheet, or
@nonterm{sheet}, is represented as a list of rows, each of which is a list of
cells. (This is the same structure as the XML application underlying ODF.)

Spreadsheets carry some metadata along with them: author, date, and so on. We
haven't figured this out yet.


@section{Values and Expressions}

In most spreadsheet programs, such as Excel, the content of a cell may be either
the literal form of an @deftech{atomic value} (specifically, a number, string,
boolean, or error) or a `formula,' representing a computation. Formulas are
distinguishable from atomic values because they start with `@tt{=}.'

In Grid, both atomic values and formulas are represented by
@deftech{expressions}. An expression may be an atomic value, a non--atomic
value, or the application of a built-in function to a set of arguments. When a
Grid program is converted to a spreadsheet the expression is converted to an
atomic value or a formula as appropriate.

A non--atomic value is either an array value or a reference. An @deftech{array
value} is a two-dimensional matrix of atomic values. (Note that array values
cannot contain non--atomic values as their elements.) A @deftech{reference} is a
pointer to another cell in the same spreadsheet. Both kinds of value can be
generated by, and consumed by, certain built-in functions.

@margin-note{In Excel, one can write array values and references as literals in
formulas. For example, @tt{={1, 2, 3; 3, 4 5}} is an array of two rows and three
columns and the function @tt{SUM()} will take an array as an argument. The
formula @tt{=OFFSET(A1, 0, 0)} includes the literal reference @tt{A1} and the
function @tt{OFFSET()} itself produces a reference as its value.}

To @emph{evaluate} a spreadsheet means to evaluate each expression to produce an
atomic value. If the final value of an expression in a cell is a non--atomic
value, the result of the cell (as `seen by' any other cell through a reference)
will be the top-left value in the array value.

@margin-note{The behaviour of Excel when the result of a formula is an array
value has changed in recent versions. Previously, a cell whose contents
evaluated to an array would appear to contain just the top-left element of the
array. However, the new behavoiur is that the elements of the array `spill' out
of the cell into adjacent cells; if these cells are not empty then a
@tt{#SPILL!} error is reported in the cell. This change is not merely a
presentational change since a reference to a cell into which a value was spilled
will now give the spilled value; whereas, previously, that cell would have been
treated as empty.}


@section{References}


@section{Styles}

Worksheets and cells carry style information (which, again, we haven't yet
figured out). The style information for worksheets refers to columns and rows
(for example, to say that certain columns or rows should be the same size, or
are `filler' columns or rows).

The style information for cells will be descriptive rather than
presentational. That is, it will not specify colours, or fonts, or other visual
effects; instead it will specify the kind of cell. For example, some cells are
`summaries' of the cells above them, in which case the system might choose to
insert a horizontal rule.


